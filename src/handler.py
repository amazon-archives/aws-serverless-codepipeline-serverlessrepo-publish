"""Lambda function handler."""

# must be the first import in files with lambda function handlers
import lambdainit  # noqa: F401
import lambdalogging

import boto3
import serverlessrepo

LOG = lambdalogging.getLogger(__name__)

CODEPIPELINE = boto3.client('codepipeline')

HIDDEN_VALUE = '__HIDDEN__'


def publish(event, context):
    """Publish to AWS Serverless Application Repository.

    CodePipeline invokes the lambda to publish an application
    to AWS Serverless Application Repository. If the application
    already exists, it will update the application metadata. Besides,
    it will create an application version if SemanticVersion is specified
    in the Metadata section of the packaged template.

    Arguments:
        event {dict} -- The JSON event sent to AWS Lambda by AWS CodePipeline
        (https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-invoke-lambda-function.html#actions-invoke-lambda-function-json-event-example)
        context {LambdaContext} -- The context passed by AWS Lambda
    """
    job_id = event['CodePipeline.job']['id']

    redacted_event = _remove_sensitive_items_from_event(event)
    LOG.info('CodePipeline publish to SAR request={}', redacted_event)

    try:
        packaged_template_str = _get_input_artifact(event)
        LOG.info('Making API calls to AWS Serverless Application Repository...')
        sar_response = serverlessrepo.publish_application(packaged_template_str)
        _put_job_success(job_id, sar_response)
    except Exception as e:
        _put_job_failure(job_id, e)


def _remove_sensitive_items_from_event(event):
    """Remove sensitive items from the CodePipeline event.

    Arguments:
        event {dict} -- The JSON event sent to AWS Lambda by AWS CodePipeline

    Returns:
        dict -- The redacted CodePipeline event

    """
    artifact_credentials = event['CodePipeline.job']['data']['artifactCredentials']
    artifact_credentials['accessKeyId'] = HIDDEN_VALUE
    artifact_credentials['secretAccessKey'] = HIDDEN_VALUE
    artifact_credentials['sessionToken'] = HIDDEN_VALUE

    return event


def _get_input_artifact(event):
    """Get the packaged SAM template from CodePipeline S3 Bucket.

    Arguments:
        event {dict} -- The JSON event sent to AWS Lambda by AWS CodePipeline

    Returns:
        str -- The content in the packaged SAM template as string

    """
    artifact_credentials = event['CodePipeline.job']['data']['artifactCredentials']
    S3 = boto3.client(
        's3',
        aws_access_key_id=artifact_credentials['accessKeyId'],
        aws_secret_access_key=artifact_credentials['secretAccessKey'],
        aws_session_token=artifact_credentials['sessionToken']
    )

    input_artifacts = event['CodePipeline.job']['data']['inputArtifacts']
    artifact_to_fetch = _find_artifact_in_list(input_artifacts)

    artifact_s3_location = artifact_to_fetch['location']['s3Location']
    bucket = artifact_s3_location['bucketName']
    key = artifact_s3_location['objectKey']

    response = S3.get_object(Bucket=bucket, Key=key)
    LOG.info('{}/{} fetched. {} bytes.', bucket, key, response['ContentLength'])
    return response.get('Body').read().decode(response['ContentLength'])


def _find_artifact_in_list(input_artifacts):
    """Find the artifact named 'PackagedTemplate' in the list of artifacts.

    Arguments:
        input_artifacts {dict list} -- list of input artifacts
        https://docs.aws.amazon.com/codepipeline/latest/APIReference/API_Artifact.html

    Raises:
        RuntimeError -- Raise error if not able to find the artifact

    Returns:
        [dict] -- artifact to fetch from S3

    """
    for artifact in input_artifacts:
        if artifact['name'] == 'PackagedTemplate':
            return artifact

    raise RuntimeError('Unable to find the artifact \'PackagedTemplate\'')


def _put_job_success(job_id, sar_response):
    """Notify AWS CodePipeline of a successful job.

    Arguments:
        job_id {str} -- The unique ID for the job generated by AWS CodePipeline
        sar_response {dict} -- The result from invoking serverlessrepo.publish_application()
    """
    LOG.info('Putting job success result...')
    CODEPIPELINE.put_job_success_result(
        jobId=job_id,
        executionDetails={
            'summary': str(sar_response),
            'percentComplete': 100
        }
    )


def _put_job_failure(job_id, e):
    """Notify AWS CodePipeline of a failed job.

    Arguments:
        job_id {str} -- The unique ID for the job generated by AWS CodePipeline
        e {Exception} -- The exception from invoking serverlessrepo.publish_application()
    """
    LOG.info('Putting job failure result...')
    CODEPIPELINE.put_job_failure_result(
        jobId=job_id,
        failureDetails={
            'type': 'JobFailed',
            'message': str(e)
        }
    )
